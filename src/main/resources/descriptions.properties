layouts=BorderLayout контейнер используемый по умолчанию в JFrame. Занимает все пространство \
  регулируемого компонента. Располагает компоненты в одной из пяти частей\
  (CENTER, WEST, EAST, NORTH , SOUTH). \
  Каждая часть содержит по одному компоненту, добавление второго перекроет первый.|\
  Менеджер последовательного расположение FlowLayout размещает компоненты \
  в контейнере центрируя слева направо, сверху вниз. При полном заполнении компонентами строки контейнера \
  FlowLayout переходит на следующую строку вниз. Данное расположение устанавливается по \
  умолчанию в панелях JPanel. В данном примере установлено выравнивание по правому краю.\n\
  new JPanel(new FlowLayout(FlowLayout.RIGHT));|\
 Менеджер расположения GridLayout представляет контейнер в виде таблицы с \
  ячейками одинакового размера. Занимает все пространство панели. Количество строк и столбцов можно \
  указать в конструкторе. Имеется возможность задать произвольное количество(передачей нулевого \
  параметра) либо строк, либо столбцов, но не одновременно. Все ячейки таблицы имеют одинаковый \
  размер, равный размеру самого большого компонента, находящегося в таблице.\
 \nnew GridLayout(2, 0, 5, 12); - строки, столбцы, отступ по горизонтали и по вертикали.|\
  Менеджер расположения BoxLayout позволяет управлять размещением компонентов либо \
  в вертикальном, либо в горизонтальном направлениях и управлять пространством между компонентами, \
  используя вставки add(Box.createVerticalStrut(50));. Для размещения компонентов в вертикальной \
  плоскости необходимо конструктору передать константу BoxLayout.Y_AXIS, для размещения в \
  горизонтальной BoxLayout.X_AXIS. Данная компоновка подходит для отображения страниц книги.|\
  Менеджер расположения GridBagLayout подобно табличному менеджеру устанавливает \
  компоненты в таблицу. Он дает возможность определять для компонентов разную ширину и высоту \
  колонок и строк таблицы. Необходимо настраивать класс GridBagConstraints для каждого добавляемого \
  компонента.\nconstraints.gridy = 0; constraints.gridx = 0; - определяют ячейку\
  \nconstraints.anchor = GridBagConstraints.PAGE_END; - якорь в конце страницы\
  \nconstraints.ipadx=45; constraints.ipady=45; - увеличить размер элемента\
  \nconstraints.weightx = 0.0 - фиксированный размер, constraints.weightx = 1.0; - занять \
  все свободное пространство.|\
  Менеджер CardLayout можно использовать для создания так называемых вкладок (tabs), \
  выбирая которые будут открываться разные панели, занимающие одно и то же место в \
  управляемом компоненте. Работает аналогично классу JTabbedPane.|\
  Менеджер расположения компонентов GroupLayout раскладывает компоненты по группам. \
  Группы имеют горизонтальное и вертикальное направление и могут быть параллельными и \
  последовательными. Необходимо расписывать последовательность элементов и по горизонтали и по \
  вертикали, также для каждой группы определяется выравнивание.|\
  OverlayLayout размещает компоненты друг над другом и использует инструменты \
  для выравнивания setAlignmentX(0.5f); и setAlignmentY(0.5f);, чтобы расположить компонент \
  относительно середины другого компонента.\n\
  setAlignmentX(1.0f); setAlignmentY(1.0f); - левый верхний угол.\n\
  setAlignmentX(0.0f); setAlignmentY(0.0f); - правый нижний угол.|\
  SpringLayout автоматически не устанавливает расположение компонентов, которыми \
  он управляет. По умолчанию все компоненты добавленные на панель расположатся в нулевой точке. \
  Чтобы скомпоновать необходимо задать расстояния между элементами(или панелью), последовательно \
  задавая привязки:  layout.putConstraint(SpringLayout.WEST , label, 10, SpringLayout.WEST , panel);\
  - сторона какого компонента относительно стороны какого компонента и на каком расстоянии.
swingcomponents=JTree дерево с MVC структурой;\n\
  DefaultTreeModel model - дифолтная реализация модели;\n\
  DefaultMutableTreeNode node - дифолтный узел, может быть и узлом и листом;\n\
  DefaultTreeCellRenderer renderer - дифолтная реализация отображения модели;\n\
  Enumeration<?> enumeration = rootNode.preorderEnumeration(); - коллекция из всех входящих нодов\n\
  tree.getLastSelectedPathComponent(); - вернет выбранный нод;\n\
  node.getChildCount() - количество входящих нодов,  node.getChildAt(i) - получение входящего нода;
